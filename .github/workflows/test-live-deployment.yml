---
name: Test Live Deployment

# This workflow tests the actual live server after deployment to the docker host
# It verifies server health, logs, and specific routing functionality
on:
  workflow_run:
    workflows: ["Deploy to Docker Host"]
    types:
      - completed
    branches: [master]
  workflow_dispatch:
    inputs:
      docker_host:
        description: 'Docker host to test (uses secret if not provided)'
        required: false
        type: string
      test_specific_route:
        description: 'Test the specific route that should avoid Overijsselselaan'
        required: false
        type: boolean
        default: true

jobs:
  test-live-deployment:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    # Only run if the deployment workflow completed successfully
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Setting up test environment variables"
          echo "DOCKER_HOST_SET=$([ -n '${{ secrets.DOCKER_HOST }}' ] && echo 'true' || echo 'false')" >> $GITHUB_ENV
          echo "SSH_KEY_SET=$([ -n '${{ secrets.SSH_PRIVATE_KEY }}' ] && echo 'true' || echo 'false')" >> $GITHUB_ENV
          echo "TEST_HOST=${{ github.event.inputs.docker_host || secrets.DOCKER_HOST }}" >> $GITHUB_ENV

      - name: Wait for deployment to settle
        if: github.event_name == 'workflow_run'
        run: |
          echo "Waiting 30 seconds for deployment to settle..."
          sleep 30

      - name: Test Live Server Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.TEST_HOST }}
          username: ${{ secrets.DOCKER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            #!/bin/bash
            set -euo pipefail
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            NC='\033[0m'
            
            # Configuration
            CONTAINER_NAME="graphhopper"
            SERVER_PORT="8989"
            ADMIN_PORT="8990"
            
            print_status() {
                local color=$1
                local message=$2
                echo -e "${color}[$(date '+%Y-%m-%d %H:%M:%S')] ${message}${NC}"
            }
            
            print_status $YELLOW "=== Starting Live GraphHopper Deployment Test ==="
            print_status $YELLOW "Container: ${CONTAINER_NAME}"
            print_status $YELLOW "Server port: ${SERVER_PORT}"
            print_status $YELLOW "Admin port: ${ADMIN_PORT}"
            
            # 1. Check if container is running
            print_status $YELLOW "1. Checking container status..."
            if docker ps --filter name=$CONTAINER_NAME --format "table {{.Names}}\t{{.Status}}" | grep -q $CONTAINER_NAME; then
                print_status $GREEN "âœ… Container '$CONTAINER_NAME' is running"
                docker ps --filter name=$CONTAINER_NAME --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            else
                print_status $RED "âŒ Container '$CONTAINER_NAME' is not running"
                print_status $YELLOW "Available containers:"
                docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
                exit 1
            fi
            
            # 2. Check container health and logs
            print_status $YELLOW "2. Checking container logs for errors..."
            
            # Check for startup errors
            if docker logs $CONTAINER_NAME --tail 50 2>&1 | grep -i "error\|exception\|failed\|cannot" | head -10; then
                print_status $YELLOW "âš ï¸  Found potential error messages in logs:"
                docker logs $CONTAINER_NAME --tail 50 2>&1 | grep -i "error\|exception\|failed\|cannot" | head -10
            else
                print_status $GREEN "âœ… No obvious error messages in recent logs"
            fi
            
            # Check for successful startup message
            if docker logs $CONTAINER_NAME 2>&1 | grep -q "Started Server"; then
                print_status $GREEN "âœ… Server startup message found in logs"
            else
                print_status $YELLOW "âš ï¸  Server startup message not found - server may still be starting"
            fi
            
            # 3. Test health endpoint
            print_status $YELLOW "3. Testing health endpoint..."
            HEALTH_TIMEOUT=60
            HEALTH_ATTEMPTS=$((HEALTH_TIMEOUT / 5))
            
            for i in $(seq 1 $HEALTH_ATTEMPTS); do
                if curl -f -s --max-time 10 http://localhost:${SERVER_PORT}/health > /dev/null; then
                    HEALTH_RESPONSE=$(curl -s --max-time 10 http://localhost:${SERVER_PORT}/health)
                    print_status $GREEN "âœ… Health endpoint responding: $HEALTH_RESPONSE"
                    break
                else
                    print_status $YELLOW "Attempt $i/$HEALTH_ATTEMPTS: Health endpoint not ready..."
                    if [ $i -eq $HEALTH_ATTEMPTS ]; then
                        print_status $RED "âŒ Health endpoint failed after $HEALTH_TIMEOUT seconds"
                        exit 1
                    fi
                    sleep 5
                fi
            done
            
            # 4. Test info endpoint and verify moped profile
            print_status $YELLOW "4. Testing info endpoint and moped profile..."
            
            # Multiple attempts to handle potential network/timing issues
            INFO_RESPONSE=""
            for attempt in 1 2 3; do
                # Use a single curl call to avoid race conditions between check and fetch
                INFO_RESPONSE=$(curl -f -s --max-time 15 http://localhost:${SERVER_PORT}/info 2>/dev/null)
                if [ $? -eq 0 ] && [ -n "$INFO_RESPONSE" ]; then
                    # Validate JSON with better error handling
                    if echo "$INFO_RESPONSE" | jq . >/dev/null 2>&1; then
                        break
                    else
                        print_status $YELLOW "Attempt $attempt: Invalid JSON response, retrying..."
                        print_status $YELLOW "Response preview: $(echo "$INFO_RESPONSE" | head -c 200)..."
                        sleep 2
                    fi
                else
                    print_status $YELLOW "Attempt $attempt: Info endpoint not responding, retrying..."
                    sleep 2
                fi
                
                if [ $attempt -eq 3 ]; then
                    print_status $RED "âŒ Info endpoint failed after 3 attempts"
                    print_status $RED "Last response: $INFO_RESPONSE"
                    exit 1
                fi
            done
            
            # Parse version safely
            VERSION=$(echo "$INFO_RESPONSE" | jq -r '.version // "unknown"' 2>/dev/null || echo "unknown")
            print_status $GREEN "âœ… Info endpoint responding. GraphHopper version: $VERSION"
            
            # Debug: Show raw response size and structure
            RESPONSE_SIZE=$(echo "$INFO_RESPONSE" | wc -c)
            print_status $YELLOW "Response size: ${RESPONSE_SIZE} characters"
            
            # Debug: Show profiles structure
            print_status $YELLOW "Profiles structure in response:"
            echo "$INFO_RESPONSE" | jq '.profiles' 2>/dev/null || print_status $RED "Could not parse profiles JSON"
            
            # Check if moped_nl profile is available using multiple approaches
            MOPED_PROFILE_FOUND="false"
            
            # Method 1: Direct jq selection
            if echo "$INFO_RESPONSE" | jq -e '.profiles[] | select(.name == "moped_nl")' >/dev/null 2>&1; then
                print_status $GREEN "âœ… moped_nl profile found (method 1: jq select)"
                MOPED_PROFILE_FOUND="true"
            fi
            
            # Method 2: Extract all profile names and grep
            if [ "$MOPED_PROFILE_FOUND" = "false" ]; then
                PROFILE_NAMES=$(echo "$INFO_RESPONSE" | jq -r '.profiles[].name' 2>/dev/null || echo "")
                if echo "$PROFILE_NAMES" | grep -q "^moped_nl$"; then
                    print_status $GREEN "âœ… moped_nl profile found (method 2: grep names)"
                    MOPED_PROFILE_FOUND="true"
                fi
            fi
            
            # Method 3: Check if profiles array contains moped_nl
            if [ "$MOPED_PROFILE_FOUND" = "false" ]; then
                if echo "$INFO_RESPONSE" | jq -r '.profiles | map(.name) | contains(["moped_nl"])' 2>/dev/null | grep -q "true"; then
                    print_status $GREEN "âœ… moped_nl profile found (method 3: contains check)"
                    MOPED_PROFILE_FOUND="true"
                fi
            fi
            
            # Final check result
            if [ "$MOPED_PROFILE_FOUND" = "true" ]; then
                print_status $GREEN "âœ… moped_nl profile is available"
            else
                print_status $RED "âŒ moped_nl profile is NOT available"
                print_status $YELLOW "Available profiles:"
                echo "$INFO_RESPONSE" | jq '.profiles' 2>/dev/null || echo "Could not parse profiles"
                print_status $YELLOW "Profile names extracted:"
                echo "$INFO_RESPONSE" | jq -r '.profiles[].name' 2>/dev/null || echo "Could not extract profile names"
                exit 1
            fi
            
            # Check if moped_access encoded value is available
            if echo "$INFO_RESPONSE" | jq -e '.encoded_values.moped_access' >/dev/null 2>&1; then
                MOPED_ACCESS_VALUES=$(echo "$INFO_RESPONSE" | jq -r '.encoded_values.moped_access | join(", ")' 2>/dev/null || echo "Could not join values")
                print_status $GREEN "âœ… moped_access encoded value available: [$MOPED_ACCESS_VALUES]"
            else
                print_status $RED "âŒ moped_access encoded value is NOT available"
                print_status $YELLOW "Available encoded values:"
                echo "$INFO_RESPONSE" | jq '.encoded_values | keys' 2>/dev/null || echo "Could not parse encoded values"
                exit 1
            fi
            
            # 5. Test basic routing functionality
            print_status $YELLOW "5. Testing basic routing functionality..."
            
            # Test with generic coordinates that should work with any dataset
            BASIC_ROUTE_URL="http://localhost:${SERVER_PORT}/route?point=42.50,1.52&point=42.51,1.53&profile=moped_nl&ch.disable=true"
            
            if BASIC_ROUTE_RESPONSE=$(curl -sf --max-time 30 "$BASIC_ROUTE_URL" 2>/dev/null); then
                if echo "$BASIC_ROUTE_RESPONSE" | jq -e '.paths[0].distance' >/dev/null 2>&1; then
                    DISTANCE=$(echo "$BASIC_ROUTE_RESPONSE" | jq -r '.paths[0].distance')
                    print_status $GREEN "âœ… Basic moped routing works! Distance: ${DISTANCE}m"
                elif echo "$BASIC_ROUTE_RESPONSE" | jq -e '.message' | grep -q "Cannot find point"; then
                    print_status $YELLOW "âš ï¸  Basic routing: Point not found (acceptable - dataset may not cover test coordinates)"
                else
                    print_status $RED "âŒ Basic routing failed with response:"
                    echo "$BASIC_ROUTE_RESPONSE" | jq '.' 2>/dev/null || echo "$BASIC_ROUTE_RESPONSE"
                    exit 1
                fi
            else
                print_status $RED "âŒ Basic routing request failed"
                exit 1
            fi
            
            # 6. Test specific route coordinates (Netherlands coordinates)
            print_status $YELLOW "6. Testing specific route that should avoid Overijsselselaan..."
            
            # Coordinates from the problem statement: 53.116614,5.781391 to 53.211454,5.803086
            SPECIFIC_FROM="53.116614,5.781391"
            SPECIFIC_TO="53.211454,5.803086"
            SPECIFIC_ROUTE_URL="http://localhost:${SERVER_PORT}/route?point=${SPECIFIC_FROM}&point=${SPECIFIC_TO}&profile=moped_nl&ch.disable=true&instructions=true"
            
            print_status $YELLOW "Testing route from $SPECIFIC_FROM to $SPECIFIC_TO"
            
            if SPECIFIC_ROUTE_RESPONSE=$(curl -sf --max-time 30 "$SPECIFIC_ROUTE_URL" 2>/dev/null); then
                if echo "$SPECIFIC_ROUTE_RESPONSE" | jq -e '.paths[0].distance' >/dev/null 2>&1; then
                    DISTANCE=$(echo "$SPECIFIC_ROUTE_RESPONSE" | jq -r '.paths[0].distance')
                    TIME=$(echo "$SPECIFIC_ROUTE_RESPONSE" | jq -r '.paths[0].time // 0')
                    print_status $GREEN "âœ… Specific route calculation successful!"
                    print_status $GREEN "   Distance: ${DISTANCE}m"
                    print_status $GREEN "   Time: ${TIME}ms"
                    
                    # Check if route uses Overijsselselaan (the route should NOT use this street)
                    if echo "$SPECIFIC_ROUTE_RESPONSE" | jq -r '.paths[0].instructions[].text // ""' | grep -qi "overijsselselaan"; then
                        print_status $RED "âŒ ROUTE VALIDATION FAILED: Route uses Overijsselselaan!"
                        print_status $RED "   The routing agent should never route over Overijsselselaan for these coordinates."
                        print_status $YELLOW "   Route instructions mentioning Overijsselselaan:"
                        echo "$SPECIFIC_ROUTE_RESPONSE" | jq -r '.paths[0].instructions[].text // ""' | grep -i "overijsselselaan" || true
                        exit 1
                    else
                        print_status $GREEN "âœ… Route validation passed: Route does NOT use Overijsselselaan"
                    fi
                    
                    # Show a sample of the route instructions for verification
                    print_status $YELLOW "Sample route instructions (first 5):"
                    echo "$SPECIFIC_ROUTE_RESPONSE" | jq -r '.paths[0].instructions[:5][] | .text // "N/A"' | head -5 || true
                    
                elif echo "$SPECIFIC_ROUTE_RESPONSE" | jq -e '.message' | grep -q "Cannot find point"; then
                    print_status $YELLOW "âš ï¸  Specific routing: Cannot find point (dataset may not cover Netherlands coordinates)"
                    print_status $YELLOW "   This is acceptable if the server is not using Netherlands OSM data"
                else
                    print_status $RED "âŒ Specific routing failed with response:"
                    echo "$SPECIFIC_ROUTE_RESPONSE" | jq '.' 2>/dev/null || echo "$SPECIFIC_ROUTE_RESPONSE"
                    exit 1
                fi
            else
                print_status $RED "âŒ Specific routing request failed"
                exit 1
            fi
            
            # 7. Test admin endpoint (if accessible)
            print_status $YELLOW "7. Testing admin endpoint..."
            if curl -f -s --max-time 10 http://localhost:${ADMIN_PORT}/healthcheck > /dev/null 2>&1; then
                print_status $GREEN "âœ… Admin endpoint responding on port ${ADMIN_PORT}"
            else
                print_status $YELLOW "â„¹ï¸  Admin endpoint not accessible (this is normal if not exposed)"
            fi
            
            # 8. Final summary
            print_status $GREEN "=== Live Deployment Test Summary ==="
            print_status $GREEN "âœ… Container is running"
            print_status $GREEN "âœ… Server health endpoint responding"
            print_status $GREEN "âœ… Server info endpoint responding"
            print_status $GREEN "âœ… moped_nl profile is available"
            print_status $GREEN "âœ… moped_access encoded values available"
            print_status $GREEN "âœ… Basic routing functionality works"
            print_status $GREEN "âœ… Specific route validation completed"
            print_status $GREEN "âœ… Route correctly avoids Overijsselselaan"
            
            print_status $GREEN "ğŸ‰ All live deployment tests PASSED!"
            print_status $YELLOW "ğŸŒ GraphHopper Maps UI: http://$(hostname -I | awk '{print $1}'):${SERVER_PORT}/"
            print_status $YELLOW "ğŸ“– API Documentation: http://$(hostname -I | awk '{print $1}'):${SERVER_PORT}/"

      - name: Report test results
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… Live deployment tests completed successfully"
            echo "The deployed GraphHopper server is working correctly and routing properly avoids Overijsselselaan"
          else
            echo "âŒ Live deployment tests failed"
            echo "Check the SSH action output above for detailed error information"
            exit 1
          fi